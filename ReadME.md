# Пример модульности в упрощенном понимании
##### (К термину "Модульное программирование" относится лишь частично. Причины в концедокумента)

Отталкиваться будем от логики, что модуль это отдельный класс и группа которая от него зависит и от которой зависит он. <br/>
К модулю так же относится и его визуальное прдеставление, если таковое имеется.

# Как  разделять
Отдельным модулем необходимо делать все. Даже ядро игры имеет смысл собирать из модулей. Желательно иметь Main-скрипт, который будет содержать первые основные модули и инициализировать их.

>
> Управление камерой - модуль. <br/>
> Сохранения - модуль. <br/>
> Каждая мини игра - модуль. <br/>
> Игровая панель - модуль. <br/>
> Строительство - модуль. <br/>

При этом модули не обязательно производят вычисления. Например:

> Когда я думаю об аккаунте, я представляю информацию, а не логику, которую он обрабатывает. То есть аккаунт просто должен содержать\хранить информацию(все данные уже ПОСЛЕ вычислений)(Прим.1)

> Когда я думаю о сохранениях, в голову приходит сразу отдельная сущность, отвечающая за сохранения, ничего при этом не визуализируя и в себе ничего кроме ссылок на объекты не храня. Какой-нибудь SaveCollector(Прим.1)

# Условия
Если у вас много объектов которые должны делать одни и те же действия, они должны оформляться как наследники модуля(Прим.1 - ObjectFromSave)

Если у вас модуль один, но вместе с ним идут скрипты с визуальным представлением и логикой не относящейся к основной, то скрипт с ОСНОВНОЙ логикой обязуется подтягивать за собой скрипты дополнительной логики через RequireComponent(Прим.2 - Rewards, View)

Миниигра, а в идеале и все сущности должны иметь явное начало и явное завершение(условно методы StartGame(or Initialize) и EndGame)(Пример.3)

Любая супер игра должна быть модульной. Что бы была возможность без проблем и лишнего кода заменить ее на другую(Пример 3.)

# Примеры

1.Первым примером будет реализация сохранений "в строку".
	Идея в том, что идея сохранения это модуль(SaveCollector). И все, что с ними взаимодействует, должны работать через подмодуль. В нашем случае это ObjectForSave. Что позволяет понимать заранее, что все объекты под этим компонентом доступны для сохранения

***
### Второй пример. 

Призван показать, что основная сущность(В данном примере SomeMiniGameLogic) должна добавлять необходимое(Rewards, View, ...) сама, т.к она без них существовать не может.
При этом в сам скрипт логики объекты эти можно притянуть в инспекторе(желательно), либо в Awake через GetComponent
***
### Третий пример 

Условная миниигра, имеющая в себе какую-то супер игру.
> 
**Исходя из этого в данном примере у нас уже 2 модуля:**
> 	1. Первый, это миниигра. 
> 	2. Второй, это супер игра. 
> 
> 	Для супер игр должен быть относительно простой шаблон для взаимодействия(в данный момент он описан в ThirdExample).
> 	Идея в том, что у супер игры есть метод открытия, закрытия и возможность передачи награды за супер игру в скрипт Rewards-основной миниигры(Логика описана в SecondExample -> SomeMiniGameLogic -> Initialization)

# FAQ
1. Почему не использовать описанную логику "Модульного программирования? 
	- Логика описанная на эту тему является излишней для большинства существующих приложений, а ее применение для игр и вовсе находится под большим вопросом, ибо делая проект слишком модульным(так как этого требует парадигма), получить что-то цельное во всех планах, будет достаточно сложно.
	+ Это приводит к лишнем тратам времени, что в большинстве случаев не допустимо

	>
